<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Hex Board Editor</title>
<style>
  body {
    font-family: sans-serif;
    background: #f4f4f4;
    padding: 10px;
  }
  canvas {
    background: #e6c27a;
    border: 1px solid #444;
    cursor: pointer;
    background-image: url('background.png');
  }
  .controls {
    margin-bottom: 10px;
  }
  .colors label,
  .rendering label {
    margin-right: 10px;
  }
  textarea {
    width: 100%;
    height: 240px;
    margin-top: 10px;
    font-family: monospace;
    white-space: pre;
  }
  label {
    font-size: 0.85em;
    opacity: 0.85;
  }
</style>
</head>
<body>

<div class="controls">
  <label>Board size:</label>
  <select id="sizeSelect">
    <option value="3">3</option>
    <option value="4">4</option>
    <option value="5">5</option>
    <option value="6">6</option>
    <option value="7" selected>7</option>
    <option value="8">8</option>
    <option value="9">9</option>
    <option value="10">10</option>
  </select>
</div>

<div class="controls colors">
  <label><input type="checkbox" value="black" checked> Black</label>
  <label><input type="checkbox" value="white" checked> White</label>
  <label><input type="checkbox" value="red"> Red</label>
  <label><input type="checkbox" value="gray"> Gray</label>
</div>

<div class="controls rendering">
  <label><input type="radio" name="renderMode" value="circle" checked> Circle</label>
  <label><input type="radio" name="renderMode" value="image"> Gloss</label>
</div>

<center>
  <canvas id="board" width="800" height="800"></canvas>
</center>

<textarea id="asciiOutput"></textarea>

<script>
const canvas = document.getElementById("board");
const ctx = canvas.getContext("2d");
const sizeSelect = document.getElementById("sizeSelect");
const asciiOutput = document.getElementById("asciiOutput");

let N = parseInt(sizeSelect.value);
let hexSize = 24;

let stones = {}; // "q,r" -> color index
let labels = {}; // "q,r" -> digit

// ---------- Procedural Go stones ----------

const stoneImages = {};
["black", "white", "red", "gray"].forEach(c => {
  const img = new Image();
  img.src = `${c}.gif`;
  stoneImages[c] = img;
});

// ---------- Maps ----------

const colorMap = {
  black: "#000000",
  white: "#ffffff",
  red:   "#cc0000",
  gray:  "#777777"
};

const asciiMap = {
  black: "x",
  white: "o",
  red:   "r",
  gray:  "g"
};

// ---------- Helpers ----------

function getRenderMode() {
  return document.querySelector("input[name=renderMode]:checked").value;
}

function getActiveColorCycle() {
  return [...document.querySelectorAll(".colors input:checked")]
    .map(cb => cb.value);
}

function axialToPixel(q, r) {
  return {
    x: hexSize * (Math.sqrt(3) * q + Math.sqrt(3) / 2 * r),
    y: hexSize * (3 / 2 * r)
  };
}

// ---------- Drawing ----------

function drawHex(x, y) {
  ctx.beginPath();
  for (let i = 0; i < 6; i++) {
    const a = Math.PI / 180 * (60 * i - 30);
    const px = x + hexSize * Math.cos(a);
    const py = y + hexSize * Math.sin(a);
    if (i === 0) ctx.moveTo(px, py);
    else ctx.lineTo(px, py);
  }
  ctx.closePath();
  ctx.stroke();
}

function drawStoneCircle(x, y, color) {
  ctx.beginPath();
  ctx.arc(x, y, hexSize * 0.6, 0, Math.PI * 2);
  ctx.fillStyle = color;
  ctx.fill();
  ctx.strokeStyle = "#000";
  ctx.stroke();
}

function drawStoneImage(x, y, colorName) {
  const img = stoneImages[colorName];
  const size = hexSize * 1.2;
  ctx.drawImage(img, x - size / 2, y - size / 2, size, size);
}

function drawLabel(x, y, text) {
  ctx.fillStyle = "#222";
  ctx.font = `${hexSize * 0.75}px sans-serif`;
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText(text, x, y);
}

function drawBoard() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.save();
  ctx.translate(canvas.width / 2, canvas.height / 2);

  const cycle = getActiveColorCycle();
  const mode = getRenderMode();

  for (let q = -(N - 1); q <= (N - 1); q++) {
    for (let r = -(N - 1); r <= (N - 1); r++) {
      if (Math.abs(q + r) >= N) continue;

      const { x, y } = axialToPixel(q, r);
      drawHex(x, y);

      const key = `${q},${r}`;

      if (stones[key] !== undefined && cycle[stones[key]]) {
        const colorName = cycle[stones[key]];
        if (mode === "image") {
          drawStoneImage(x, y, colorName);
        } else {
          drawStoneCircle(x, y, colorMap[colorName]);
        }
      } else if (labels[key]) {
        drawLabel(x, y, labels[key]);
      }
    }
  }

  ctx.restore();
}

// ---------- Interaction ----------

canvas.addEventListener("click", (e) => {
  const cycle = getActiveColorCycle();
  if (cycle.length === 0) return;

  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left - canvas.width / 2;
  const my = e.clientY - rect.top - canvas.height / 2;

  let best = null;
  let bestDist = Infinity;

  for (let q = -(N - 1); q <= (N - 1); q++) {
    for (let r = -(N - 1); r <= (N - 1); r++) {
      if (Math.abs(q + r) >= N) continue;
      const { x, y } = axialToPixel(q, r);
      const d = Math.hypot(mx - x, my - y);
      if (d < bestDist && d < hexSize * 0.7) {
        bestDist = d;
        best = { q, r };
      }
    }
  }

  if (!best) return;

  const key = `${best.q},${best.r}`;
  delete labels[key]; // placing stone clears label

  stones[key] = (stones[key] === undefined) ? 0 : stones[key] + 1;
  if (stones[key] >= cycle.length) delete stones[key];

  drawBoard();
  exportASCII();
});

sizeSelect.addEventListener("change", () => {
  N = parseInt(sizeSelect.value);
  stones = {};
  labels = {};
  drawBoard();
  exportASCII();
});

document.querySelectorAll(".colors input, .rendering input").forEach(el =>
  el.addEventListener("change", () => {
    drawBoard();
    exportASCII();
  })
);

// ---------- ASCII Export / Import ----------

function exportASCII() {
  const cycle = getActiveColorCycle();
  let lines = [];

  for (let r = -(N - 1); r <= (N - 1); r++) {
    let line = " ".repeat(Math.abs(r));

    for (let q = -(N - 1); q <= (N - 1); q++) {
      if (Math.abs(q + r) >= N) continue;

      const key = `${q},${r}`;
      if (stones[key] !== undefined && cycle[stones[key]]) {
        line += asciiMap[cycle[stones[key]]] + " ";
      } else if (labels[key]) {
        line += labels[key] + " ";
      } else {
        line += ". ";
      }
    }
    lines.push(line.trimEnd());
  }

  asciiOutput.value = lines.join("\n");
}

function importASCII() {
  const rows = asciiOutput.value
    .split("\n")
    .map(line => [...line].filter(c => "xorg.0123456789".includes(c)))
    .filter(row => row.length > 0);

  if (rows.length === 0) return;

  const newN = Math.ceil((rows.length + 1) / 2);
  N = newN;
  sizeSelect.value = N;

  stones = {};
  labels = {};

  const cycle = getActiveColorCycle();
  const colorIndex = {};
  cycle.forEach((c, i) => colorIndex[c] = i);

  const rMin = -(N - 1);

  rows.forEach((row, rowIndex) => {
    const r = rMin + rowIndex;

    const qs = [];
    for (let q = -(N - 1); q <= (N - 1); q++) {
      if (Math.abs(q + r) < N) qs.push(q);
    }

    for (let i = 0; i < Math.min(row.length, qs.length); i++) {
      const symbol = row[i];
      const key = `${qs[i]},${r}`;

      if (symbol === ".") continue;

      if ("0123456789".includes(symbol)) {
        labels[key] = symbol;
        continue;
      }

      const color =
        symbol === "x" ? "black" :
        symbol === "o" ? "white" :
        symbol === "r" ? "red"   :
        symbol === "g" ? "gray"  : null;

      if (color && colorIndex[color] !== undefined) {
        stones[key] = colorIndex[color];
      }
    }
  });

  drawBoard();
  exportASCII();
}

asciiOutput.addEventListener("blur", importASCII);
asciiOutput.addEventListener("keydown", e => {
  if (e.ctrlKey && e.key === "Enter") importASCII();
});

// ---------- Init ----------

drawBoard();
exportASCII();
</script>

</body>
</html>
