<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>WAG's Board Viewer</title>

<style>
body { 
  font-family: sans-serif; 
  background:#f4f4f4; 
  padding:10px; 
}
canvas { 
  background:#e6c27a; 
  border:1px solid #444; 
  cursor:pointer; 
  background-image: url('background.png');
}
textarea {
  width:100%;
  height:220px;
  font-family:monospace;
  white-space:pre;
}
select { 
  margin-right:10px; 
}
label {
  font-size: 0.85em;
  opacity: 0.85;
}

</style>
</head>

<body>

<select id="boardType">
  <option value="hex">Hex</option>
  <option value="sq-inter">Square (intersections)</option>
  <option value="sq-cell">Square (cells)</option>
</select>

<select id="sizeSelect">
  <option>3</option>
  <option>4</option>
  <option>5</option>
  <option>6</option>
  <option selected>7</option>
  <option>8</option>
  <option>9</option>
  <option>10</option>
  <option>11</option>
  <option>12</option>
  <option>13</option>
  <option>14</option>
  <option>15</option>
  <option>16</option>
  <option>17</option>
  <option>18</option>
  <option>19</option>
</select>


<label>
  <span title="x/black o/white r/red g/gray">Color cycle:<span>
  <input id="cycleInput" value="x o r g" size="8">

  <input type="checkbox" id="useImages">
  Use Go-style stones
</label>

<br><br>

<canvas id="board" width="900" height="900"></canvas>

<textarea id="ascii"></textarea>

<script>
const canvas = document.getElementById("board");
const ctx = canvas.getContext("2d");
const ascii = document.getElementById("ascii");
const sizeSelect = document.getElementById("sizeSelect");
const boardTypeSelect = document.getElementById("boardType");
const cycleInput = document.getElementById("cycleInput");
const useImagesCheckbox = document.getElementById("useImages");

let N = Number(sizeSelect.value);
let boardType = boardTypeSelect.value;

const hexSize = 26;
const cellSize = 48;

let stones = {}; // key -> x o r g
let digits = {}; // key -> 0..9

// ---------------- IMAGES ----------------

const stoneImages = {
  x: new Image(),
  o: new Image(),
  r: new Image(),
  g: new Image()
};

stoneImages.x.src = "black.gif";
stoneImages.o.src = "white.gif";
stoneImages.r.src = "red.gif";
stoneImages.g.src = "gray.gif";

let imagesReady = {
  x: false,
  o: false,
  r: false,
  g: false
};

for (const k in stoneImages) {
  stoneImages[k].onload = () => imagesReady[k] = true;
}

// ---------------- COLORS ----------------

const colorMap = {
  x: "#000",
  o: "#fff",
  r: "#c00",
  g: "#888"
};

function cycleList() {
  return cycleInput.value
    .trim()
    .split(/\s+/)
    .filter(c => colorMap[c]);
}

// ---------------- DRAW ----------------

function drawBoard() {
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.save();
  ctx.translate(canvas.width/2, canvas.height/2);
  ctx.strokeStyle = "#000";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.font = `${cellSize*0.45}px sans-serif`;

  if (boardType === "hex") {
    const R = N-1;
    for (let q=-R;q<=R;q++)
      for (let r=-R;r<=R;r++) {
        if (Math.abs(q+r)>=N) continue;
        const x = hexSize*(Math.sqrt(3)*q + Math.sqrt(3)/2*r);
        const y = hexSize*(1.5*r);
        drawHex(x,y);
        const k=`${q},${r}`;
        if (stones[k]) drawStone(x,y,stones[k]);
        else if (digits[k]) drawDigit(x,y,digits[k]);
      }
  }

  if (boardType === "sq-inter") {
    const span=(N-1)*cellSize, h=span/2;
    for (let i=0;i<N;i++) {
      const p=-h+i*cellSize;
      ctx.beginPath();
      ctx.moveTo(-h,p); ctx.lineTo(h,p);
      ctx.moveTo(p,-h); ctx.lineTo(p,h);
      ctx.stroke();
    }
    for (let i=0;i<N;i++)
      for (let j=0;j<N;j++) {
        const x=-h+i*cellSize, y=-h+j*cellSize;
        const k=`${i},${j}`;
        if (stones[k]) drawStone(x,y,stones[k]);
        else if (digits[k]) drawDigit(x,y,digits[k]);
      }
  }

  if (boardType === "sq-cell") {
    const span=N*cellSize, h=span/2, hc=cellSize/2;
    for (let i=0;i<=N;i++) {
      const p=-h+i*cellSize;
      ctx.beginPath();
      ctx.moveTo(-h,p); ctx.lineTo(h,p);
      ctx.moveTo(p,-h); ctx.lineTo(p,h);
      ctx.stroke();
    }
    for (let i=0;i<N;i++)
      for (let j=0;j<N;j++) {
        const x=-h+i*cellSize+hc, y=-h+j*cellSize+hc;
        const k=`${i},${j}`;
        if (stones[k]) drawStone(x,y,stones[k]);
        else if (digits[k]) drawDigit(x,y,digits[k]);
      }
  }

  ctx.restore();
}

function drawHex(x,y) {
  ctx.beginPath();
  for (let i=0;i<6;i++) {
    const a=Math.PI/180*(60*i-30);
    const px=x+hexSize*Math.cos(a);
    const py=y+hexSize*Math.sin(a);
    i?ctx.lineTo(px,py):ctx.moveTo(px,py);
  }
  ctx.closePath();
  ctx.stroke();
}

function drawStone(x, y, c) {
  if (
    useImagesCheckbox.checked &&
    stoneImages[c] &&
    imagesReady[c]
  ) {
    const img = stoneImages[c];
    const r = cellSize * 0.35;
    ctx.drawImage(img, x - r, y - r, r * 2, r * 2);
    return;
  }

  // fallback circle
  ctx.beginPath();
  ctx.arc(x, y, cellSize * 0.35, 0, Math.PI * 2);
  ctx.fillStyle = colorMap[c];
  ctx.fill();
  ctx.stroke();
}


function drawDigit(x,y,d) {
  ctx.fillStyle="#000";
  ctx.fillText(d,x,y);
}

// ---------------- CLICK ----------------

canvas.onclick = e => {
  const rect=canvas.getBoundingClientRect();
  const mx=e.clientX-rect.left-canvas.width/2;
  const my=e.clientY-rect.top -canvas.height/2;
  let key=null;

  if (boardType==="hex") {
    const R=N-1;
    let best=Infinity;
    for (let q=-R;q<=R;q++)
      for (let r=-R;r<=R;r++) {
        if (Math.abs(q+r)>=N) continue;
        const x=hexSize*(Math.sqrt(3)*q + Math.sqrt(3)/2*r);
        const y=hexSize*(1.5*r);
        const d=Math.hypot(mx-x,my-y);
        if (d<best && d<hexSize*0.7) {
          best=d; key=`${q},${r}`;
        }
      }
  }

  if (boardType==="sq-inter") {
    const span=(N-1)*cellSize, h=span/2;
    let best=Infinity;
    for (let i=0;i<N;i++)
      for (let j=0;j<N;j++) {
        const x=-h+i*cellSize, y=-h+j*cellSize;
        const d=Math.hypot(mx-x,my-y);
        if (d<best && d<cellSize*0.45) {
          best=d; key=`${i},${j}`;
        }
      }
  }

  if (boardType==="sq-cell") {
    const span=N*cellSize, h=span/2;
    const i=Math.floor((mx+h)/cellSize);
    const j=Math.floor((my+h)/cellSize);
    if (i>=0&&i<N&&j>=0&&j<N) key=`${i},${j}`;
  }

  if (!key) return;

  const cycle=cycleList();
  const cur=stones[key];
  const idx=cycle.indexOf(cur);

  delete digits[key]; // stone always clears digit

  if (idx===-1) stones[key]=cycle[0];
  else if (idx===cycle.length-1) delete stones[key];
  else stones[key]=cycle[idx+1];

  drawBoard();
  exportASCII();
};

// ---------------- ASCII ----------------

function exportASCII() {
  let out=[];
  if (boardType==="hex") {
    const R=N-1;
    for (let r=-R;r<=R;r++) {
      const qMin=Math.max(-R,-r-R);
      const qMax=Math.min( R,-r+R);
      let line=" ".repeat(Math.abs(r));
      for (let q=qMin;q<=qMax;q++) {
        const k=`${q},${r}`;
        line+= (stones[k] || digits[k] || ".") + " ";
      }
      out.push(line.trimEnd());
    }
  }

  if (boardType.startsWith("sq")) {
    for (let j=0;j<N;j++) {
      let line="";
      for (let i=0;i<N;i++) {
        const k=`${i},${j}`;
        line+= (stones[k] || digits[k] || ".") + " ";
      }
      out.push(line.trimEnd());
    }
  }
  ascii.value=out.join("\n");
}

function importASCII() {
  stones={};
  digits={};
  const lines=ascii.value.split("\n");

  if (boardType==="hex") {
    const R=N-1;
    let r=-R;
    for (const raw of lines) {
      if (r>R) break;
      const cells=raw.trim().split(/\s+/);
      const qMin=Math.max(-R,-r-R);
      const qMax=Math.min( R,-r+R);
      let qi=0;
      for (let q=qMin;q<=qMax && qi<cells.length;q++,qi++) {
        const c=cells[qi];
        const k=`${q},${r}`;
        if (colorMap[c]) stones[k]=c;
        else if (/^[0-9]$/.test(c)) digits[k]=c;
      }
      r++;
    }
  }

  if (boardType.startsWith("sq")) {
    for (let j=0;j<Math.min(N,lines.length);j++) {
      const cells=lines[j].trim().split(/\s+/);
      for (let i=0;i<Math.min(N,cells.length);i++) {
        const c=cells[i];
        const k=`${i},${j}`;
        if (colorMap[c]) stones[k]=c;
        else if (/^[0-9]$/.test(c)) digits[k]=c;
      }
    }
  }

  drawBoard();
}

ascii.addEventListener("keydown", e=>{
  if (e.key==="Enter") {
    e.preventDefault();
    importASCII();
  }
});

// ---------------- UI ----------------

function refresh() {
  N=Number(sizeSelect.value);
  boardType=boardTypeSelect.value;
  stones={};
  digits={};
  drawBoard();
  exportASCII();
}

sizeSelect.onchange=refresh;
boardTypeSelect.onchange=refresh;

refresh();
</script>

</body>
</html>
