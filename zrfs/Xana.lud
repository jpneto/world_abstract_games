// Xana - by João Pedro Neto
//------------------------------------
// 
(define "PiecesPerplayer" <Board:pieceCount>)
(define "Opponent" (- 3 (mover)))
(define "BoardSitesOf" (intersection (sites Occupied by:(player #1)) (sites Board)))
(define "DistanceFromToIf"
 (count Steps Orthogonal
  (step (to if:#3))
  #1
  #2
))

(define "SitesWithinCircleAtRadius"
 (forEach
  (sites Distance Orthogonal 
   from:#1 
   (range 0 #2)
  )
  if:(and
   (is Empty (site))
   (!= Infinity ("DistanceFromToIf" #1 (site) (is Empty (to))))
)))
 

(define "AccessibleSitesOf"
 (forEach
  (intersection (sites Empty) (sites Board))
  if:(and
   (not (no Pieces of:#1 in:(sites Board)))
   (!= Infinity
    ("DistanceFromToIf"
     (site)
     ("BoardSitesOf" #1)
     (or (is Empty (to)) (is In (to) ("BoardSitesOf" #1)))
)))))

(define "WithinUnplayedDistance"
 (forEach
  of:("BoardSitesOf" (mover))
  ("SitesWithinCircleAtRadius" (site)
   (+ 1
    (count Sites
     in:(intersection
      (sites Occupied by:Mover) 
      (sites Hand Mover)
))))))


(define "AllCircleSites"
 (forEach
  of:("BoardSitesOf" (mover))
  ("SitesWithinCircleAtRadius" (site) (size Stack at:(site)))
))

(define "SitesWithinCircleAtUsingPathDistance" // not used
 (sites Distance Orthogonal 
  (step (to if:(is Empty (to))))
  from:#1 
  (range 0 (size Stack at:#1))
))

(define "HeightAt"
// (where Level at:#1) 
 (count Stack at:#1) 
// (size Stack at:#1) 
// (topLevel at:#1)
)
(define "ToEmptySpaces"
 (to (intersection (sites Empty) (sites Board))
  (apply (set Var "LF" (from)))
))

(define "ToStackPlacementSites"
 (to
  (union 
   ("BoardSitesOf" (mover))
   ("AccessibleSitesOf" (mover))
  )
  (apply (set Var "LF" (from)))
))

(define "AvailablePiecesOf" 
 (- ("PiecesPerplayer") (max 0 (value Player (- 3 #1))))
)

(define "AddAStack"
 (move 
  (from (sites Hand Mover))
  #1
  (then
   (remove (forEach (sites Hand Mover) if:(> (site) (var "LF"))) 
    (then 
     (add
      (to (last To))
      count:(- ("AvailablePiecesOf" (mover)) (count Pieces Mover))
      stack:True
))))))

(define "MoveAStack"
 (forEach Piece
  (move Select
   (from (from) level:(level))
   (to           
    ("SitesWithinCircleAtRadius" (from) (size Stack at:(from)))
    (apply (set Var "LF" (from)))
   )
   (then
    (add
     (to (last To))
     count:(-
      (+ 1 (topLevel at:(last From))) 
      (last LevelFrom)
     )
     stack:True
     (then
      (remove
       (last From)
       count:(size Stack at:(last To))
)))))))

(define "HasLibertyAt" 
 (< 1 (count Sites in:(sites Around #1 Orthogonal if:(is Empty (to)))))
)

(define "MarkDead"
 (forEach Site 
  (intersection
   (sites Board)
   (union
    (sites Occupied by:(player 1))
    (sites Occupied by:(player 2)) 
  ))
  (if
   (> 1 (size Array (array (sites Around (site) if:(is Empty (to))))))
   (set State at:(site) 1)
   (if
    (!= 0 (state at:(site)))
    (set State at:(site) 0)
))))

(define "DeadOf" (intersection ("BoardSitesOf" #1) (sites State 1)))
(define "DeadAndAdjacentStonesOfIf" 
 (sites Around ("DeadOf" #1) Orthogonal if:#2 includeSelf:True)
)
(define "RecordCapturesOf"
 (set Value (player (- 3 #1)) (- ("PiecesPerplayer") (count Pieces of:#1))) 
)
(define "Remove"
 (move Select (from ("DeadOf" #1))
  (then
   (remove #2
    count:(count Pieces All in:#2) 
    (then ("RecordCapturesOf" #1))
))))

(define "AutoRemove"
 (remove #2
  count:(count Pieces of:#1 in:#2) 
  (then ("RecordCapturesOf" #1))
))

(define "Suicide" ("Remove" (mover) <Mover:removalSites>))  // e.g. ("DeadAndAdjacentStonesOfIf" (mover) "IsAnyStone")
(define "Capture" ("Remove" ("Opponent") <Opponent:removalSites>)) 
(define "AllRemovalSites"  (union <Mover:removalSites> <Opponent:removalSites>))
(define "CaptureAll"
 (if (= #1 (mover))
  ("Remove" (mover) <Mover:removalSites>) 
  ("Remove" ("Opponent") <Opponent:removalSites>) 
))
(define "AutoCaptureAllOf"
 (if (= #1 (mover))
  ("AutoRemove" (mover) <Mover:removalSites>) 
  ("AutoRemove" ("Opponent") <Opponent:removalSites>) 
))
(define "AutoCaptureAllAtOnce"
 (remove
  ("AllRemovalSites") 
  count:(count Pieces All in:("AllRemovalSites")) 
  (then (and ("RecordCapturesOf" 1) ("RecordCapturesOf" 2)))
))

--------------------------------------------------- 
// Main routine
//------------------------------------

(game "Xana" 
 (players 2)
 (equipment
  {
   (board  <Board:type> use:Cell)
   (hand Each size:("PiecesPerplayer"))
   (piece "Stone" Each)
   (piece "Wall" Neutral)
  }
 )
 (rules
  (start 
   {
    (place  "Stone1" (sites Hand P1))
    (place  "Stone2" (sites Hand P2))
   }
  )
  (play
   (priority
    {
     (or  // or is used here simply to append a consequence for the capture moves.
      {<Capture:bySelection>}
      (then (if (< 0 (var "WallsToPlay")) (moveAgain)))
     )
     (or
      (move Pass (then (set Var "WallsToPlay" 0)))    // Passes are allowed
      (if
       (or 
        (= 3 (var "WallsToPlay")) // was Swap
        ("NewTurn")
       ) 
       (or
        (if            // Pie move
         (and
          {
           (> 3 (counter)) 
           (>= 0 (var "WallsToPlay"))
           (no Pieces P2 in:("BoardSitesOf" 2))
          }
         )
         (move Swap Players 1 2 (then (set Var "WallsToPlay" 3)))
        )
        (if
         (and (> 10 (counter)) (no Pieces of:(mover) in:(sites Board)))
         (do
          (set Value Mover 0)
          next:("AddAStack" "ToEmptySpaces")
         )
         (or
          ("AddAStack" ("ToStackPlacementSites"))
          ("MoveAStack")
         )
         (then (set Var "WallsToPlay" 2 (then (moveAgain))))      
       ))
       // same turn:
       (if
        (< 0 (var "WallsToPlay"))
        (move Add
         (piece "Wall0") 
         (to <Walls:restriction>)
         (then
          (set Var "WallsToPlay" (- (var "WallsToPlay") 1)
           (then (if (< 0 (var "WallsToPlay")) (moveAgain)))
     ))))))
    }
    (then
     (priority
      {
       <Capture:ifAutomatic>
       (and
        {
         (set Score P1 (+ (value Player P1) (count Sites in:("AccessibleSitesOf" 1))))
         (set Score P2 (+ (value Player P2) (count Sites in:("AccessibleSitesOf" 2))))
        }
       )
      }
  ))))
  (end 
   {
    (if
     (and
      ("EndCondition")
      (= (score P1) (score P2))
     )
     (result P1 Win)
    )
    (if
     ("EndCondition")
     (byScore)
    )
   }
)))

//----------------------------------
(define "EndCondition"
 (or
  (all Passed) 
  (and
   (< 10 (counter))
   (= 0
    (+
    (count Sites in:(sites State 1))
     (count Sites
      in:(intersection
       ("AccessibleSitesOf" 1) 
       ("AccessibleSitesOf" 2)
)))))))

(option "Board" <Board> args:{ <type> <pieceCount> }
 {
  (item "Hex6"  <(hex Hexagon 6)>  <12>  "Board: 6 Hexagon")
  (item "Hex7"  <(hex Hexagon 7)>  <14>  "Board: 7 Hexagon")
  (item "Hex8"  <(hex Hexagon 8)>  <16>  "Board: 8 Hexagon")**
  (item "Hex9"  <(hex Hexagon 9)>  <18>  "Board: 9 Hexagon")
 }
)

(option "Wall Placement" <Walls> args:{<restriction>}
 {
  (item "Where Accessible" <("AccessibleSitesOf" (mover))> "Standard Game")
  (item "Within a stack circle" 
   <("AllCircleSites")> "Walls must be placed within the circle of one of a players stacks.")
  (item "Distance Limited"
   <("WithinUnplayedDistance")> "Walls must be placed on accessible spaces around any friendly stacks within a distance of one plus the count of unplaced friendly pieces.")
 }
)

(option "Captures" <Capture> args:{ <ifAutomatic> <bySelection> }
 {
  (item "Automatically All at Once" 
   <(seq { "MarkDead" "AutoCaptureAllAtOnce" })> 
   <> 
   "Implementation automatically removes all dead at once"
  )
  (item "Automatic Enemies first" 
   <(seq { "MarkDead" ("AutoCaptureAllOf" "Opponent") "MarkDead" ("AutoCaptureAllOf" (mover))})> 
   <("CaptureAll" "Opponent") ("CaptureAll" (mover))> 
   "Implementation automatically removes dead enemies, then dead Friends"
  )**
  (item "Enemies then Friends" 
   <"MarkDead"> 
   <(priority ("CaptureAll" "Opponent") ("CaptureAll" (mover)))> 
   "Select to remove dead enemies, then dead Friends"
  )
  (item "One at a time Enemies first" 
   <"MarkDead"> 
   <(priority ("Capture") ("Suicide"))> 
   "Select stacks individually to remove dead enemies, then dead Friends"
  )
  (item "One at a time" 
   <"MarkDead"> 
   <("Capture") ("Suicide")> 
   "Select stacks individually to remove dead enemies, then dead Friends"
  )
 }
)

(define "IsAnyStone" (<= 0 (who at:(to))))
(define "IsAnyStack" (< 0 (who at:(to))))
(define "IsEnemyStack" (= "Opponent" (who at:(to))))
(define "IsFriendlyStack" (= (mover) (who at:(to))))
(define "IsWallStone" (= 0 (who at:(to))))
(define "IsEnemyOrWallStone" (or (= 0 (who at:(to))) (= "Opponent" (who at:(to)))))
(define "IsFriendOrWallStone" (or (= 0 (who at:(to))) (= (mover) (who at:(to)))))

(option "Suicide Bombs" <Mover> args:{<removalSites>}
 {
  (item "Not Applicable" <("DeadOf" (mover))>
   "Standard Game")
  (item "Remove adjacent walls" <("DeadAndAdjacentStonesOfIf" (mover) ("IsWallStone"))> 
   "Suicides destroy adjacent walls")
  (item "Remove walls and stacks" <("DeadAndAdjacentStonesOfIf" (mover) ("IsAnyStone"))> 
   "Suicides destroy adjacent walls and stacks")
 }
)

(option "Capture Bombs" <Opponent> args:{<removalSites>}
 {
  (item "Not Applicable" <("DeadOf" ("Opponent"))> "Standard Game")
  (item "Remove adjacent walls" <("DeadAndAdjacentStonesOfIf" ("Opponent") ("IsWallStone"))> 
   "Suicides destroy adjacent walls")
  (item "Remove walls and stacks" <("DeadAndAdjacentStonesOfIf" ("Opponent") ("IsAnyStone"))> 
   "Suicides destroy adjacent walls and stacks")
 }
)

//----------------------------------

(metadata
 (info
  {
   (description "Xana by João Pedro Neto")   
   (rules "The game is played on a hexhex board of size 8.

There are, off board, 16 white stones, 16 black stones, and enough neutral stones (known as walls). The white and black stones should be stackable.

Definitions
  • A stack is a tower of one or more friendly stones.
  • A stack has liberty if at least one of the adjacent hexes is empty (there is no concept of group of stacks)
  • A hex is accessible if it is empty and connected to a friendly stack by a path of empty hexes
  • The distance between two hexes is the number of steps in the shortest path connecting them (hex occupancy is irrelevant)
  • The circle of a stack of height H is the set of all accessible hexes within distance H.

Rules
  • On their turn, a player must choose one of the following actions:
      • Pass
      • Drop a stack onto an accessible hex or on top of a friendly stack
      • Move a stack, or part of it, to another hex within its circle
  • Then, optionally, the player may place one or two walls on accessible hexes, one after the other (not simultaneously)
  • After each move or placement, any stack (of either color) without liberties is captured
      • Resolve enemy captures first, then friendly captures
  • Pie rule: On their first turn, the second player may choose to swap colors instead of making a move
  • The game ends when both players pass. The player with the highest score wins
      • Scoring: one point per accessible hex, one point per captured stone, the first player receives an additional 0.5 points."
   )

   (version "1.3.13")
   (classification "board/space/blocking")
   (author "João Pedro Neto")
   (credit "Dale W. Walton")
   (date "2025-07")
  }
 )
 
 (graphics
  {
   (board Colour Phase0 (colour 254 243 231))
   (board Colour OuterEdges (colour Black))
   (board Colour InnerEdges (colour Black))
   (board StyleThickness OuterEdges 1.5)
   (board StyleThickness InnerEdges 0.4)
   (board StyleThickness InnerVertices 0.4)
   (board StyleThickness OuterVertices 0.4)
   (piece Scale .85)
   (piece Rename P1 "Disc") 
   (piece Rename P2 "Disc") 
   (piece Rename Neutral "Disc") 
   (player Colour P1 (colour 90 190 220))
   (player Colour P2 (colour White))
   (player Colour Neutral (colour Red))
   (hand Placement P1 scale:.85 offsetX:.1 offsetY:.12 vertical:False)
   (hand Placement P2 scale:.85 offsetX:.1 offsetY:.91 vertical:False)
   (stackType 0 Default 1.6)
   (stackType 1 Count)
   (stackType 2 Count)
   (piece Foreground state:1 image:"Disc" fillColour:(colour 254 243 231 150) edgeColour:(colour 254 243 231 150))
//   (show Piece Value Middle scale:.5)
//   (show Piece State scale:.7)
  }
 )
 
 (ai
  (bestAgent "UCT")
//  (alphaBeta
//   (heuristics
//    {
//     (lineCompletionHeuristic weight:-3 targetLength:2)
//    }
//))
))

